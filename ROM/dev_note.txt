指令集：
0x00    nop                                 空指令
0x01    end                                 终止解释器
0x02    rst                                 复位解释器

跳转指令只允许在当前的代码段内跳转
0x03    jmp  addr                           直接跳转
0x04    jz   addr           rs == 0 ? jmp   零则跳转
0x05    jnz  addr           rs != 0 ? jmp   非零则跳转
0x06    jg   addr           rs >  0 ? jmp   大于则跳转
0x07    jl   addr           rs <  0 ? jmp   小于则跳转
0x08    cmp  r0, r1         rs = r0 - r1    比较
0x09	test r0		        rs = sign(r1)   测试

0x10    mov  r0, r1         r0 = r1         数据传送，寄存器到寄存器或者立即数到寄存器
0x11    push r0                             入栈
0x12    pop  r0                             出栈
0x13    prt  r0                             打印到上位机发送缓冲区，指针累加
0x14    hidp                pushHIDData()   将发送缓冲区内数据发送至上位机并清空（发送整个缓冲区）
0x15    strp                pushStrData()   将发送缓冲区内数据按字符串通过模拟按键发送至上位机（给定延时，逐字符模拟，并复位打印指针，发送指针范围内）
0x16    in   r0, r1         r0 = getkey(r1) 读取按键索引r1的状态到r0，按下为1，否则为0
0x17    out  r0, r1         setkey(r0, r1)  将按键数据索引r0的键值设置为r1
0x18    keyp                pushKeydata()   将按键数据发送到上位机
0x19    ldi  r0, r1         r0 = read_i(r1) 读取内部flash中r1偏移地址到r0
0x1A    lde  r0, r1         r0 = read_e(r1) 读取外部flash中r1偏移地址到r0
0x1B    wri  r0, r1         write_i(r0, r1) 将r1写入到内部flash中r0偏移地址
0x1C    wre  r0, r1         write_e(r0, r1) 将r1写入到外部flash中r0偏移地址

0x20    add  r0, r1, r2     r0 = r1 + r2    加法
0x21    inc  r0             r0 += 1         加一
0x22    sub  r0, r1, r2     r0 = r1 - r2    减法
0x23    dec  r0             r0 -= 1         减一
0x24    mul  r0, r1, r2     r0 = r1 * r2    乘法
0x25    div  r0, r1, r2     r0 = r1 / r2    除法
0x26    mod  r0, r1, r2     r0 = r1 % r2    求余

0x30    and  r0, r1, r2     r0 = r1 & r2    与
0x31    or   r0, r1, r2     r0 = r1 | r2    或
0x32    xor  r0, r1, r2     r0 = r1 ^ r2    异或
0x33    not  r0             r0 = ~r0        非
0x34    shl  r0, r1         r0 = r0 << r1   左移
0x35    shr  r0, r1         r0 = r0 >> r1   右移

0x40    sleep r0            delay_tick(r0)  延时毫秒，通过定时器计数刻来实现
// led序号的低8位为序号本身，高8位为可选的RGB565到RGB888的扩展位
0x41    led  r0, r1         setled(r0, r1)  将r0序号的led颜色设置为r1，并清空渐变列表
0x42    time r0             settime(r0)     设置渐变持续时间，r0取0则为终止标记
0x43    fade r0, r1         addfade(r0, r1) 将r1颜色添加到r0序号的led渐变列表，在下个解释器执行周期会开始执行渐变列表
0x44    trig r0, r1         setTrig(r0, r1) 设置r0序号的led渐变触发方式，r0为0x00不触发，对应位取1通过对应按键触发，按键之间为或关系
0x45    rgb  r0, r1                         设置r0序号的led为rgb渐变模式，其中r1取值：0-不设置为rgb渐变，1-设置为渐变但不响应触发，1-反向渐变并不响应触发，2-响应触发并在响应时切换渐变方向

特殊指令：
0x50    sysrst 0xAA, 0x55                   系统软复位
0x51    reload 0x55, 0xAA                   重载程序至xRAM
0x55    iap  0xAA, 0x55                     进入IAP模式

==================================================================================
实际实现的指令集

NUM     op   dt, d, st, s
0x00    nop                                 空指令
0x01    jmp  addr                           直接跳转
0x02    clr                                 复位上位机发送缓冲区指针
0x03    prt  r0                             打印到上位机发送缓冲区，指针累加
0x04    hidp                pushHIDData()   将发送缓冲区内数据发送至上位机并清空
0x05    strp r0             pushStrData()   将发送缓冲区内数据按字符串通过模拟按键发送至上位机
0x06    out  r0, r1         setkey(r0, r1)  将按键数据索引r0的键值设置为r1
0x07    keyp                pushKeydata()   将按键数据发送到上位机
0x08    ldi  r0, r1         r0 = read_i(r1) 读取内部flash中r1偏移地址到发送缓冲区偏移r0
0x09    lde  r0, r1         r0 = read_e(r1) 读取外部flash中r1偏移地址到发送缓冲区偏移r0
0x0A    wri  r1, r0         write_i(r0, r1) 将r1写入到内部flash中r0偏移地址
0x0B    wre  r1, r0         write_e(r0, r1) 将r1写入到外部flash中r0偏移地址
0x0C    sleep 0, r0         delay_tick(r0)  延时毫秒，通过定时器计数刻来实现
0x0D    led  0, r0, 0, r1   setled(r0, r1)  将r0序号的led颜色设置为r1，并清空渐变列表
0x0E    time 0, r0          settime(r0)     设置渐变持续时间，r0取0则为终止标记
0x0F    fade 0, r0, 0, r1   addfade(r0, r1) 将r1颜色添加到r0序号的led渐变列表
0x10    trig r0, r1         setTrig(r0, r1) 设置r0序号的led渐变触发方式
0x11    rgb  r0, r1                         设置r0序号的led为rgb渐变模式
0x12    sysrst 0x55, 0xAA55                 系统软复位
0x13    reload 0xAA, 0x55AA                 重载程序至xRAM
0x14    iap  0x5A, 0xA55A                   进入IAP模式

==================================================================================

存储器地址分配：
类别    地址（0x00~0x80为内部flash，否则为外部存储器，程序空间需在寄存器之后，如0x0030）
BTC     0x0000      双字节，按键触发控制，每两位决定一个按键的触发模式（按下，抬起，持续按下，不使用）
BT1     0x0002      双字节，最高位为键值/地址选择位，取0时低8位为键值，取1时低15位为程序地址
BT1L    0x0004      双字节，上述程序长度，上述选择位取0时忽略
BT2     0x0006      双字节，最高位为键值/地址选择位，取0时低8位为键值，取1时低15位为程序地址
BT2L    0x0008      双字节，上述程序长度，上述选择位取0时忽略
BT3     0x000A      双字节，最高位为键值/地址选择位，取0时低8位为键值，取1时低15位为程序地址
BT3L    0x000C      双字节，上述程序长度，上述选择位取0时忽略
BT4     0x000E      双字节，最高位为键值/地址选择位，取0时低8位为键值，取1时低15位为程序地址
BT4L    0x0010      双字节，上述程序长度，上述选择位取0时忽略
BT5     0x0012      双字节，最高位为键值/地址选择位，取0时低8位为键值，取1时低15位为程序地址
BT5L    0x0014      双字节，上述程序长度，上述选择位取0时忽略
LED1    0x0016      双字节，灯光初始化程序地址，为0xFFFF时为单一颜色初始化
LED1L   0x0018      双字节，上述程序长度，上述程序地址为0xFFFF时为RGB565颜色值
LED2    0x001A      双字节，灯光初始化程序地址，为0xFFFF时为单一颜色初始化
LED2L   0x001C      双字节，上述程序长度，上述程序地址为0xFFFF时为RGB565颜色值
LED3    0x001E      双字节，灯光初始化程序地址，为0xFFFF时为单一颜色初始化
LED3L   0x0020      双字节，上述程序长度，上述程序地址为0xFFFF时为RGB565颜色值
LED4    0x0022      双字节，灯光初始化程序地址，为0xFFFF时为单一颜色初始化
LED4L   0x0024      双字节，上述程序长度，上述程序地址为0xFFFF时为RGB565颜色值
LED1EX  0x0026      单字节，LED1的颜色扩展位，从高到低分别为R2 R1 R0 G1 G0 B2 B1 B0
LED2EX  0x0027      单字节，LED2的颜色扩展位，从高到低分别为R2 R1 R0 G1 G0 B2 B1 B0
LED3EX  0x0028      单字节，LED3的颜色扩展位，从高到低分别为R2 R1 R0 G1 G0 B2 B1 B0
LED4EX  0x0029      单字节，LED4的颜色扩展位，从高到低分别为R2 R1 R0 G1 G0 B2 B1 B0
（已分配42字节，内部Data Flash容量为128字节）

对于多媒体按键，需手动设置按键数据0为报告ID 2，并置按键数据1为对应的多媒体键值

对于BTC寄存器，通过两位确定一个按键的触发模式：
不使用：0x0，按下：0x1，抬起：0x2，持续按下：0x3
整个双字节如下：（从高到低排列）
15  14  13  12  11  10  9   8   7   6   5   4   3   2   1   0
*   *   *   *   *   *   BT5 BT5 BT4 BT4 BT3 BT3 BT2 BT2 BT1 BT1
其中高6位目前为保留位，暂不使用

在按下和抬起模式中，如果宏指令包含循环结构，并且当前已经有宏程序在循环执行，此时的触发停止对应的循环，不执行宏代码
在持续按下模式中，如果宏指令包含循环结构，此时的宏执行效果是未知的（如果是死循环宏）；一旦抬起按键将中断当前的宏执行
如果指令执行做成在大循环内单步执行，就可以避免这些问题（解释器循环合并入主循环）


